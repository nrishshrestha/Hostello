[`Main.java`](http://Main.java) app entry point this is the first program file that will run.

Model ‚Üí just to get the value from the database and send value to database.

DAO‚Üí Handles DB operations like sending and receving the data through querys.

`MySqlConnection.java`: Connects to MySQL through the url password and username.

View‚Üí this foleder contains Jframe forms that the user sees and interact with.

# Explanation

# RegisterView

[RegisterView.java](http://RegisterView.java) ‚Üí create it by JFrame Form no class or panel. Then make GUI manually.

Source‚Üí

Package declaration:

```java
package view;
```

This says your `RegisterView` class belongs to the `view` package.
In MVC (Model-View-Controller), "RegisterView" is displayed to user as Signup page.

```java
import javax.swing.JButton;
import javax.swing.JLabel;
```

These are classes that will be used when i make a function to return a button or lable as in return type i have to write these classes.

- `JButton` = button.
- `JLabel` = text or image label.
- Swing is Java‚Äôs built-in library to make GUIs.

```java
public class RegisterView extends javax.swing.JFrame {
```

defining a public class called `RegisterView`.
`extends JFrame` means you're making a window (a GUI frame) that users can interact with using JFrame form not Jpanel or class.

CONSTRUCTOR

```java
public RegisterView() {
    initComponents();
}
```

This is an auto generated constructor.

`initComponents()` is a **method automatically generated** by NetBeans (or any GUI builder) that:

> ‚öôÔ∏è Initializes all the components of the GUI ‚Äî text fields, buttons, labels, layout, fonts, positions, everything.
> 

You don‚Äôt write this method by hand. NetBeans writes it when you use its **drag-and-drop designer**.

Imagine you dragged a button and named it `registerButton`. `initComponents()` does this under the hood:

```java
registerButton = new JButton("Register");
registerButton.setFont(new Font("Segoe UI", Font.PLAIN, 14));
registerButton.setBounds(100, 150, 200, 40);
getContentPane().add(registerButton);
```

GETTER METHODS

so we know that the controller uses the inputs and the button clicks like signup etc but these fiels are here so we need to send these fields to the controller but we dont export them but we make methods when called from controller returns these fields.

This is how controller can get items from view. 

```java
public String getNameInput() {
    return nameField.getText().trim();
}

```

the nameField is an object of Jtext class and this class has an method called the getText() that returns a string from that text field so the nameField.getText() returns a string of name written in that text filed with variable name namefield. So we are using the String as return type as the function returns the Sting and trin() function is of string class and it removes white spaces from a string.

```java
public String getEmailInput() {
    return emailField.getText().trim();
}

```

Same as above but for email input.

```java
public String getPasswordInput() {
    return new String(passwordField.getPassword()).trim();
}

```

Here we are not accesing the passpord as other input fields 

Because passwordField is of Jpassword class and this class provides a method getpassword() but this returns a array of chars not string as others. So we need to convert the arry of chars into String for that we use a syntax that creates a string object. it is like saying 

```java

ClassName obj =new ClassName(arg);
return new ClassName(arg)//  same as above
```

same is done here but with string syntax

```java
return new String(passwordField.getPassword()).trim();
```

Then trim the spaces.

GETTERS for action

we know our button is clicked here in this view but the logic should be in the controller so we pass the regisster button og this page in gui to the controller and in controller we can attach the action listioner their not here so even if the action listioer is attached in controller it would be attached to the obj button itself that is the obj will have even listioner but will redirect to the controller as there is its logic.

These are for attaching logic to your GUI components from the controller.

the return type is JButton cause the registerbutton is being returned and the JButton is its class.

```java
public JButton getRegisterButton() {
    return registerButton;
}

```

Returns the register button object so controller can add an action listener.

```java
public JLabel getRedirectLoginLabel() {
    return redirectLogin;
}
```

- Returns the "Already have an account? Login" label.
- Controller can add a click listener to this to go to the login page.

MAIN METHOD

Auto generated by the netbeans

```java
public static void main(String args[]) {
    java.awt.EventQueue.invokeLater(new Runnable() {
        public void run() {
            new RegisterView().setVisible(true);
        }
    });
}
```

This is not used here as it is for testing and we access the register view from controller.

VARIABLES DECLARATION (Made by GUI builder)

```java
// Variables declaration - do not modify
private javax.swing.JLabel TitleLable;
private javax.swing.JTextField emailField;
private javax.swing.JLabel emailLabel;
private javax.swing.JTextField nameField;
private javax.swing.JLabel nameLabel;
private javax.swing.JPasswordField passwordField;
private javax.swing.JLabel passwordLabel;
private javax.swing.JLabel redirectLogin;
private javax.swing.JButton registerButton;
// End of variables declaration

```

# RegisterController.java

Package Declaration

```java
package controller;
```

Imports ‚Äì Bringing Tools

```java
import dao.UserDao;
import model.UserData;
import view.RegisterView;
import view.LoginView;

import javax.swing.*;
import java.awt.event.*;

```

- `UserDao`: Class that handles **database operations** for users
- `UserData`: Model class that holds **user details**
- `RegisterView` & `LoginView`: Screens (GUI) for user registration and login
- `javax.swing.*`: Tools for GUI (like buttons, dialog boxes)

This imports all the classes of wiing button password field etc at once previously in register view we did 

`import javax.swing.JButton;
import javax.swing.JLabel;`

- `java.awt.event.*`: Listeners that wait for **user actions** like clicks. it gives us listioner obj to attach to the buttons.

```java
public class RegisterController {
```

we didnt extend it cause we use java class to make it not jFrame form.

Private Fields

```java
private RegisterView registerView;
private UserDao userDao;
```

The whole register view page is a class and that class is called RegisterView as in source of register view the controller calls the init function that initilizes the class so the RegisterView is the whole registerview page.

here registerview is being set as a empty variable that will store the instance of the RegisterView class. So we can use the obj to call that class or do things in that class.

And userdao is a empty variable thats type is of userDao class. 

Constructor: Setting Up the Controller

```java
public RegisterController(RegisterView registerView) {
    this.registerView = registerView;
    this.userDao = new UserDao();  // DAO to talk to database

```

This is the constructor‚Äîit runs first before anything in this class **when you create a new object** of this class.

It takes a `RegisterView` obj as a parameter, so it can work with the GUI.

Making the object of the Register view and UserDao so we can work wth them.

- `this.registerView = registerView;`: Save the GUI object for later use
- `this.userDao = new UserDao();`: Create the DAO that handles the database

The open() method below that opens the register view has a code like loginView.setVisible(). The login view is an obj as to do any page setvisible yopu need to make a obj of that page class and call setvisible on it casue in oop you dont use the method of a class without instance until it belongs to the class or is static. so. to run open() we would need a obj of login view which we could directly import the class and make or we take that as parameter when some one calls the registercontroller and that argument will be passed to the conastructor then the constructor attaches the registerview obj directly to the obj using this. and we declared a empty variable of lOgin view befor be cause you can ‚Äòt use this. keyword until you declare the varible first and that varible is already saved in the obj as instance variable then this.loginview takes the variable from obj then asigns the para of loginview obj.

```java
RegisterController controller = new RegisterController(new RegisterView());
controller.open();
```

this code is used in other pages where you need to call register controller class you make its instance by passing the para that its constructor searches for.

Thsis same for the login also.

Registering Event Listeners

```java

this.registerView.getRegisterButton().addActionListener(new RegisterAction());
this.registerView.getRedirectLoginLabel().addMouseListener(new RedirectToLogin());

```

These two lines say:

**"When the button is clicked or the label is clicked, run my code."**

```java
this.registerView.getRegisterButton().addActionListener(new RegisterAction());
this.registerView.getRedirectLoginLabel().addMouseListener(new RedirectToLogin());

```

here we are accessing the register buttion that is returned by the getRegisterbutton in the RegisterView class and we are doinfg it by usiung its obj and adding an action listioner manually to th ebutton obj by using the .addActionListioner function and passing a action obj that is the obj of the same class MouseAdapter as the method addAction Listioner asks for a action obj as argument that will run when the regsiter button is performed so we ca‚Äôt jus tprovide it with method.

So, the addActionLictioner will be attached when this class instance is made that means inside [main.java](http://main.java) class.

here the addActionListioner needs a obj that has the methods from the interface Action Listiner and the class RegisterAction implements or inherit the ActionListioner interface. So addActionerListioner will accept that obj then inside the addactionlistioner a obj gets inside it as paramether and this addactionListione rsearches for a method called action performed that takes actionevent obj as parameter if found it runs is so our code is written inside that. So RegisterAction is a obj and objs are not callable like functions but here the function inside that obj is called and searched bu the addactionlistioner obj itself when action on the button is performed.

Methods: Opening and Closing the View

We will be opening the register view from terh controller so for that 

```java
public void open() {
    registerView.setVisible(true);
}
```

when this open() method is called it will open the register view.

```java
public void close() {
    registerView.dispose();
}

```

Action class to create a action  obj for event listioners.

What Happens on Register Button Click

```java
class RegisterAction implements ActionListener {
    @Override
    public void actionPerformed(ActionEvent e) {

```

This is the **code that runs when the user clicks the Register button**.

 Step 1: Get Input From the GUI

```java
String name = registerView.getNameInput();
String email = registerView.getEmailInput();
String password = registerView.getPasswordInput();

```

These lines grab the text the user typed into the form by using the getter methods from the register view that returns thes fields..

Step 2: Basic Validation

```java
if (name.isEmpty() || email.isEmpty() || password.isEmpty()) {
    JOptionPane.showMessageDialog(registerView, "All fields are required.");
    return;
}

```

f any field is empty, show an error popup and **stop execution** with `return that exist this function.`

 Step 3: Create a User Object

We know that the controller access the values and events and pass the values to the mode directory as it contains the values to send to the databse and has the valuse send by the datbase through dao.

```java
UserData user = new UserData(name, email, password, "warden");

```

 This line builds a UserData object using input values.

 Step 4: Send to Database

As said earlier userDao deals with all the database activates.

```java
boolean success = userDao.register(user);

```

This calls the `register()` method of `UserDao`, which inserts the user into the database.
Returns `true` if successful.

Step 5: Feedback and Redirect

```java
if (success) {
    JOptionPane.showMessageDialog(registerView, "Registration successful!");
    close();
    new LoginController(new LoginView()).open();
} else {
    JOptionPane.showMessageDialog(registerView, "Registration failed. Try again.");
}

```

Another class to hande redirect ot the login page if "Already have an account?‚Äù.

```java
class RedirectToLogin extends MouseAdapter {
    @Override
    public void mouseClicked(MouseEvent e) {
        close();
        LoginController lcontroller = new LoginController(new LoginView());
lcontroller.open();

    }
}
```

When the label is clicked:

- Close Register window
- Open the Login window

```java
LoginController controller = new LoginController(new LoginView());
controller.open();

```

Here the mehtod to open() the loginView is inside the login controller class but to use a class in another file we need to create its obj by using new LoginVontroller but the login controller class requires a parameter that requires a obj of Loginvie that is send to the constructor and it makes a view obj for the login view cause to write the logic of login view you would need an the loginview class instance .setvisible() inside the login controller. So when you do this new LoginController(new LoginView()) it passes the instance of loginview to the constructor that creates a obj of login view then when you call .open fron theLogincontroller obj it will do the view.setvisible wher visible is saved in the obj LoginController with the this. keyword.

# Login View

 Package Declaration

```java
package view;
```

 Imports

```java
import java.awt.event.ActionListener;
import java.awt.event.MouseListener;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPasswordField;
import javax.swing.JTextField;

```

- `ActionListener`: Listens to button clicks.
- `MouseListener`: Listens to mouse clicks (for labels that act like links).
- `JButton`, `JLabel`, `JPasswordField`, `JTextField`: UI elements.

Class Definition

```java
public class LoginView extends javax.swing.JFrame {
```

You‚Äôre creating a class called `LoginView`, and it extends `JFrame`, which means it is a full windowed UI.

Constructor

```java
public LoginView() {
    initComponents();
}
```

The constructor runs when you create a new `LoginView` object. It calls `initComponents()`, which is an auto-generated method that creates and arranges all your GUI elements like buttons, labels, etc.

 Getter Methods

Just likr register view we wont be writting the logic code here for button clocked so we need to make getter methods that r eturn ui compnents like text fields and buttons. textfields that contains the user text will be converted to the string them will be returned and the buttons obj will be returned to attach event listioner to them.

```java
public String getEmailTextField() {
    return txtEmail.getText().trim();
}
```

This returns the text written in the email field. `.trim()` removes spaces before and after the text.

```java
public String getPasswordField() {
    return new String(pwdPassword.getPassword()).trim();
}
```

Password is stored as a character array for security. You convert it to a string, then remove extra spaces.

```java
public JButton getLoginButton() {
    return btnLogin;
}
```

Gives access to the Login button object, used later in the controller to add a listener.

```java
public JLabel getRedirectLogin() {
    return lblRedirectRegister;
}

```

Gives access to the ‚ÄúDon‚Äôt have an account?‚Äù label. It acts like a clickable link.

main() Method

same as register view

 Variable Declarations (Auto-managed by GUI Editor)

```java
private javax.swing.JButton btnLogin;
private javax.swing.JLabel jLabel4;
private javax.swing.JLabel lblEmail;
private javax.swing.JLabel lblPassword;
private javax.swing.JLabel lblRedirectRegister;
private javax.swing.JPasswordField pwdPassword;
private javax.swing.JTextField txtEmail;

```

# LoginController

`import` statements

```java
import dao.UserDao;
import model.UserData;
import view.LoginView;
import view.AdminDashboardView;
import view.WardenDashboardView;
import javax.swing.*;
import java.awt.event.*;

```

- `UserDao` lets you **talk to the database**‚Äîto check credentials.
- `UserData` is the **model object** that holds user information like email, password, and role.
- `LoginView` is the **form** the user sees and types into.
- `AdminDashboardView` and `WardenDashboardView` are what they see after login.
- `JOptionPane` is used to **show pop-up messages.**
- `ActionListener` and `MouseListener` let you **handle button clicks and mouse actions.**

Class Declaration

```java
public class LoginController {

```

Fields

```java
private LoginView loginView;
private UserDao userDao;

```

**They are implementation details.**

- You don't want some other class changing your view or database object.
- Imagine someone outside calls:
    
    `loginController.loginView.setVisible(false);`
    
    Now the UI disappears without warning. That‚Äôs **bad design**.
    

Constructor

```java
public LoginController(LoginView loginView) {
    this.loginView = loginView; // Ignoring passed view and creating new one
    this.userDao = new UserDao();
```

same as in registercontroller

Adding Listeners 

```java
this.loginView.getLoginButton().addActionListener(new LoginHandler());
this.loginView.getRedirectLogin().addMouseListener(new RedirectToRegister());

```

Same as register controller

`LoginHandler` - Handles Login Button

```java
class LoginHandler implements ActionListener {
    public void actionPerformed(ActionEvent e) {

```

This class responds to the **Login** button press.

```java
String email = loginView.getEmailTextField();
String password = loginView.getPasswordField();

```

Pulls the user‚Äôs email and password from the form.

```java
if (email.isEmpty() || password.isEmpty()) {
    JOptionPane.showMessageDialog(null, "Fill in all fields");
    return;
}
```

If any field is empty, it shows a warning and exits the function.

```java
UserData user = userDao.login(email, password);
```

Sends the credentials to `UserDao.login()` which queries the database. If a match is found, it returns a `UserData` object.

```java
if (user != null) {
    JOptionPane.showMessageDialog(null, "Login Success");
    loginView.dispose(); // Close current login window

```

If login is successful, you show a message and close the login window.

```java
if (user.getRole().equals("admin")) {
    new AdminDashboardController().open();
} else {
    new WardenDashboardController().open();
}

```

- You check the **role** (`admin` or `warden`).
- You open the correct dashboard controller.

If login fails:

```java
JOptionPane.showMessageDialog(null, "Invalid credentials");

```

`RedirectToRegister` - Handles Register Label

This listens for mouse clicks on "Don't have an account?" label.

```java
class RedirectToRegister extends  MouseAdapter {
        @Override
        public void mouseClicked(MouseEvent e) {
        close();
        new controller.RegisterController(new view.RegisterView()).open();
    }

```

Open and Close Methods

```java
public void open() {
    loginView.setVisible(true);
}

public void close() {
    loginView.dispose();
}

```

# DbConnection

```java
package database;
```

```java
import java.sql.Connection;
```

This line tells Java to bring in the `Connection` class from the `java.sql` package.

- **Connection** is a special Java class that represents an **open connection to your database**.

`Connection` is an class that is used to make a connection variable that will store the conncetion obj of type Connection class returned When you call `DriverManager.getConnection()`, it returns an **object** that *implements* that `Connection` class. That object *represents* the actual live connection to your database. So that obj returned by the get Connection is of type Connection class.

This connection is how your Java program talks with the database, sends commands, and gets results.

```java
public interface DbConnection {

```

- You‚Äôre declaring a **public interface** called `DbConnection`.
- **Interface** in Java is a **contract** or a **blueprint** that says: *Any class that ‚Äúimplements‚Äù me must provide these specific methods*.

```java
    Connection openConnection();
```

This is a **method declaration** inside the interface that returns type Connection.
It will be used to establish connection to the database. So calling this method from anywhere will establish the database connection and return a collection obj. This returned obj ‚Üíhas A live link to the database, Methods to execute commands `PreparedStatement` objects etc,Connection metadata.

```java
    void closeConnection(Connection conn);

```

It takes the conncetion returned by openconnection as parameter.

- This method will be implemented to **close** the database connection, freeing resources.
- Closing connections is important to prevent leaks that slow down or crash your system.

# MySqlConnection

```java
package database;
```

```java
import java.sql.Connection;
import java.sql.DriverManager;
```

- `Connection`: The interface representing the connection to the database (the bridge we talked about).
- `DriverManager`: The manager that has methods to establish a data base connection and return a connection obj.

```java
public class MySqlConnection implements DbConnection {

```

- This declares a new class called **`MySqlConnection`**.
- It **implements** the interface `DbConnection`. This means `MySqlConnection` **must define** the methods declared in `DbConnection` (which are `openConnection()` and `closeConnection(Connection)`).

```java
public Connection openConnection() {

```

- This method is called **`openConnection`** and its job is to **open the connection to the database**.
- It returns a `Connection` object

```java
try {

```

If anything goes wrong (an error or exception), it will jump to the `catch` block ‚Äî so your program doesn‚Äôt crash without explanation.

```java
String username = "root";
String password = "admin123";
String url = "jdbc:mysql://localhost:3306/hostel";

```

 define three **strings** holding the credentials and location info for your database.

```java
Class.forName("com.mysql.cj.jdbc.Driver");

```

It tells Java to **load the MySQL driver class into memory**.

If this driver isn‚Äôt available, your program won't know how to connect to MySQL.

```java
Connection conn = DriverManager.getConnection(url, username, password);

```

This line actually opens the connection using `DriverManager`.
If successful, it stores the connection in the`conn` variable.

- **the `DriverManager` to create a real connection** to the database using the URL, username, and password you set.
- `getConnection()` opens the channel and returns the `Connection` object ‚Äî the bridge to your database.
- This connection obj will be used later to send queries, retrieve data, etc.

```java
return conn;

```

You return this **active connection** so other parts of your program can use it.

```java
} catch (Exception e) {
    System.out.println("Error connecting to database: " + e.getMessage());
    return null;
}

```

- If anything fails inside the `try` block (wrong password, no database running, driver missing), this block runs.
- It prints the error message so you know what went wrong.
- Then it returns `null` ‚Äî meaning no connection was made.
- Returning `null` is a signal to the rest of your program that something failed.

```java
public void closeConnection(Connection conn) {

```

- This is the method to **close the connection** when you‚Äôre done.
- It takes the `Connection` object you want to close as a parameter.

```java
try {
    if (conn != null && !conn.isClosed()) {
        conn.close();
    }
} catch (Exception e) {
    System.out.println("Error closing connection: " + e.getMessage());
}

```

- You first check if the connection is not `null` (meaning it exists).
- Then you check if it‚Äôs not already closed.
- If both true, you call `conn.close()` ‚Äî this frees resources, closes the channel with the database.

# UserDao

```java
import database.MySqlConnection;
import model.UserData;
import java.sql.ResultSet;
import java.sql.Connection;
import java.sql.PreparedStatement;

```

- `MySqlConnection`: Your personal connection class that opens/closes a line to your MySQL database.
- `UserData`: The model class that holds user info.
- `ResultSet`, `Connection`, `PreparedStatement`: These are standard JDBC (Java Database Connectivity) tools to run SQL queries, hold database connections, and process results.

Class Definition:

```java
public class UserDao {

```

This is the **UserDao class**‚Äîyour *database operations guy*. You call him when you want to `register` or `login` users.

 Field Declaration:

```java
MySqlConnection mySql = new MySqlConnection();

```

You created an object `mySql` of your custom class `MySqlConnection`. Cause Mysql class has openconnection and to use it we need an obj of that class.
You‚Äôll use it to `openConnection()` and `closeConnection()`.

`register(UserData user)` Method ‚Äî INSERTING A USER

```java
public boolean register(UserData user) {
    String query = "INSERT INTO users(username, email, password, role) VALUES (?, ?, ?, 'warden')";

```

- You‚Äôre making a method `register` that takes a `UserData` object.
- `String query` is your SQL command to insert the data into the `users` table.
- `'warden'` is hardcoded‚Äîevery user you register will have the role `'warden'`.

```java
Connection conn = mySql.openConnection();

```

You're asking your `MySqlConnection` object to open a connection to the database and hold it in `conn`.

```java
try {
    PreparedStatement stmnt = conn.prepareStatement(query);

```

- You're preparing the SQL statement safely (to avoid SQL injection).
- `stmnt` is now your SQL execution tool.

```java
    stmnt.setString(1, user.getUsername());
    stmnt.setString(2, user.getEmail());
    stmnt.setString(3, user.getPassword());

```

Here, you're replacing the `?` placeholders in the SQL query with actual data from the `user` object.

- `1` ‚Üí username
- `2` ‚Üí email
- `3` ‚Üí password

```java
    int result = stmnt.executeUpdate();
    return result > 0;

```

- You execute the query send the datat to database. `executeUpdate()` returns how many rows were inserted.
- If it inserted at least 1 row, return `true` (successful registration).

```java
} catch (Exception e) {
    System.out.println("Error in register: " + e.getMessage());
    return false;

```

```java
} finally {
    mySql.closeConnection(conn);
}

```

- Whether the registration was successful or failed, this will **always** run.
- It closes the connection so you don't keep holding on to the database‚Äîalways clean up.

`login(String email, String password)` Method ‚Äî AUTHENTICATING A USER

```java
public UserData login(String email, String password) {
    String query = "SELECT username, email, password, role FROM users WHERE email = ? AND password = ?";

```

- This method takes email and password, then tries to find a matching user.
- The query looks into the database for a record that has this exact email and password.

```java
Connection conn = mySql.openConnection();

```

Open a connection to the database.

```java
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setString(1, email);
stmt.setString(2, password);

```

Prepare the query and replace `?` with actual values safely.

```java
ResultSet rs = stmt.executeQuery();

```

Reasultset is a class used to declare a result set variable that stores the reselt set obj returned by the select query.
Execute the query and store the **results** (a row from the database) in `rs`.

If this query finds a row where both `email` and `password` match, then that row is **fetched** from the `users` table its pointer is  stored in the `ResultSet` `rs`.

| id | name | email | password | role |
| --- | --- | --- | --- | --- |
| 1 | John Doe | [admin@email.com](mailto:admin@email.com) | 1234 | admin |
- **Why:** You want to check if any record matches those credentials.
- **How:**
    - `executeQuery()` runs the SELECT command.
    - It returns a `ResultSet` object `rs` ‚Äî a pointer to the rows found.
    - If no row, `rs` is empty.
    
    if rs has 1 row the pointer will always will be before that row which will be empty so if you will try to read rs.getString() it will give error as their is no row but if 1 row exist then the pinter will shift from before that row to that row using next(_) that gives true but if 0 rows ar fount then the pointer shifted will reach no row.
    

```java
if (rs.next()) {

```

If a user exists with that email and password, `rs.next()` will return `true` and move to that row.

- Without `rs.next()`, the pointer is at position **before the first row**, and trying to get data like `rs.getString()` will throw an error ‚Äî because there‚Äôs no row under the pointer.
- After `rs.next()` returns `true`, the pointer sits on row 1 ‚Äî and you're allowed to access its columns using `getString("columnName")`, `getInt("id")`, etc.

```java
    String username = rs.getString("username");
    String userEmail = rs.getString("email");
    String userPassword = rs.getString("password");
    String role = rs.getString("role");

    return new UserData(username, userEmail, userPassword, role);

```

- You fetch the values from the row one by one.
- Then you **create a new `UserData` object** using the data. That object is returned to the caller (like the `LoginController`).

# Model

# UserData

```java
public class UserData {

```

- Here you declare a **class named `UserData`**.
- This class is **public**, meaning it can be accessed from other parts of your program.

The userdata objs will store different 

```java
private String username;
private String email;
private String password;
private String role;

```

- `username`: the user‚Äôs name or handle.
- `email`: their email address.
- `password`: their password (ideally, you would hash it, but here it‚Äôs plain).
- `role`: their role in the system (e.g., "warden", "admin").

```java
public UserData(String username, String email, String password, String role) {
    this.username = username;
    this.email = email;
    this.password = password;
    this.role = role;
}

```

It sets all the fields at once for all.
This is a **constructor** method.

- `this.username = username;` means: assign the value passed in the parameter `username` to the **class variable** `username`.
- `this` keyword refers to **this object‚Äôs own field**.

**getters and setters** ‚Äî these are your controlled gates to access or modify the private fields.

```java
public String getUsername() {
    return username;
}

```

```java
public void setUsername(String username) {
    this.username = username;
}

```

AdminDashBoardView

```java
package view;

```

```java
import java.awt.event.ActionListener;
import javax.swing.JButton;
```

Till now in admin dashboard onlt the logut button is added so i need toi return the button to add event listioner to it through the controller.

- `ActionListener` lets your program **listen for button clicks** or user actions.
- `JButton` is the Swing component that represents a **clickable button** on the screen.

```java
public class AdminDashboardView extends javax.swing.JFrame {

```

- You declare your class `AdminDashboardView`.
- It **extends** `JFrame`, meaning it **is a window** in your app ‚Äî a top-level container where you put components.
- So this class is your Admin Dashboard **window**.

```java
public AdminDashboardView() {
    initComponents();
}

```

Inside, it calls `initComponents()` ‚Äî a method that **builds and arranges all the buttons, labels, and layout** of your window.

```java
public JButton getLogoutButton() {
        return LogoutBtn;
    }
```

returning the button to addaction listioner in the controller.

# AdmindashboardController

```java
import view.AdminDashboardView;
import view.LoginView;
```

These two lines **import** classes from the `view` package.

```java
public class AdminDashboardController {

```

This creates a **public class** named `AdminDashboardController`.

Define a private field:

```java
private AdminDashboardView view;
```

We declare a variable `view` of type `AdminDashboardView`.
Constructor: This is called when you create a new AdminDashboardController:

```java
public AdminDashboardController() {
```

Inside the constructor:

```java
this.view = new AdminDashboardView();
```

- `this.view` refers to the variable declared earlier.
- We are **creating a new instance** of `AdminDashboardView`, i.e., opening the admin dashboard GUI.

```java
this.view.getLogoutButton().addActionListener(e -> close());
```

getLogoutButton() is a method from the `AdminDashboardView` class.
The part `e -> close()` is a **lambda expression** (fancy name for a short function).

> Creating an anonymous object of a class that implements ActionListener, and inside that object, the actionPerformed() method will call close().‚Äù
> 

In Java 8 and above, this shortcut syntax is possible **only** because `ActionListener` is a **functional interface** ‚Äî meaning it has only **one method**: `actionPerformed(ActionEvent e)`.

open() method

```java
public void open() {
    view.setVisible(true);
}

```

close() method

```java
private void close() {
view.dispose();
new LoginController(new LoginView()).open();
}
```

Same for wardendashboard

# Main

### `import controller.RegisterController;`

### `import view.RegisterView;`

- `RegisterController`: Controls the logic for your Register screen.
- `RegisterView`: The actual UI (form) where the user enters their data.

### `public class main {`

This declares a **class** named `main`.

### `public static void main(String[] args) {`

This is **the real start point** of your Java application.

The JVM (Java Virtual Machine) looks for this exact method signature to run your code.

### `javax.swing.SwingUtilities.invokeLater(() -> { ... });`

This line is **very important** when you're building a GUI with Swing.

Why?

Because Swing is **not thread-safe** ‚Äî all UI code **must run on the Event Dispatch Thread (EDT)**.

So `SwingUtilities.invokeLater()` makes sure your GUI code runs on the correct thread.

The arrow `()->{}` is a **lambda expression** ‚Äî it's just a short way to define code that should run later.

### Now Inside the Lambda:

### `RegisterView registerView = new RegisterView();`

You're creating an object of your GUI class ‚Äî the **Register screen**.

This is the form the user will see with input fields for username, email, password, etc.

### `RegisterController registerController = new RegisterController(registerView);`

You're creating the **controller** for the Register screen.

- It connects the UI (`RegisterView`) with the logic (how to handle registration).

### `registerController.open();`

This tells the controller to **open the registration screen** ‚Äî to make it visible.

### 1. **UserData.java (Model)**

- It carries user information ‚Äî username, email, password, and role.
- It holds **data only** ‚Äî no decisions, just getters and setters to access and update info.
- Used to pass data from UI to the backend and vice versa.
- It‚Äôs the foundation of every user-related transaction in your system.

---

### 2. **UserDao.java (Data Access Object)**

- The **gatekeeper to your database**.
- Contains methods to talk directly to the database:
    - `register()` inserts a new user into the database.
    - `login()` fetches a user based on email and password.
- Converts database rows into `UserData` objects and vice versa.
- Handles SQL queries and connections. Your data moves through this guy.
- Keeps the database code separate from business logic ‚Äî clean and professional.

---

### 3. **DbConnection.java (Interface)**

- This is the **contract** every database connection class must follow.
- Declares two essential methods:
    - `openConnection()` ‚Äî to open a connection to the database.
    - `closeConnection(Connection conn)` ‚Äî to close it safely.
- By using an interface, you can swap databases or connection methods without breaking your system.
- Keeps your code flexible and strong.

---

### 4. **MySqlConnection.java (Implementation of DbConnection)**

- **who actually connects to MySQL**.
- Implements `openConnection()` to establish a connection using JDBC with specific credentials and URL.
- Implements `closeConnection()` to properly close that connection.
- Handles driver loading (`Class.forName(...)`), connection creation, and error management.
- Ensures your app talks to MySQL properly and safely.

---

### 5. **LoginView.java (View)**

- **the face of your login system**.
- This is the GUI (Graphical User Interface) where users enter email and password.
- Contains text fields, buttons, and maybe some labels.
- Sends user input to the controller and shows success or failure messages.
- Does *not* deal with logic or data ‚Äî only interaction and display.

---

### 6. **LoginController.java (Controller)**

- **runs the login operation**.
- Listens to user actions from `LoginView` ‚Äî like pressing the login button or clicking ‚Äúregister.‚Äù
- Calls `UserDao.login(email, password)` to check credentials.
- Handles success (open dashboard based on user role) or failure (show error).
- Controls flow between UI (LoginView) and data (UserDao/UserData).
- Manages events and delegates tasks like opening the right dashboard.

---

### 7. **AdminDashboardView.java & WardenDashboardView.java (View)**

- These are **the private offices** where admin or warden users land after successful login.
- Each dashboard displays features and controls relevant to that role.
- Like a VIP lounge for your respected user types.
- These views are *different*, catering to different needs and permissions.

---

### 8. **AdminDashboardController.java & WardenDashboardController.java (Controller)**

- The **managers of the respective dashboards**.
- Control the behavior of admin or warden dashboards.
- Handle interaction inside dashboards, load data, respond to user commands.
- Maintain the role-based segregation of power and access.

---

### 9. **RegisterController.java & RegisterView.java**

- Similar to Login, but for **new user registration**.
- `RegisterView` gets user input for new registration.
- `RegisterController` handles validation, calls `UserDao.register()` to save new user.
- Connects new users to the system.

---

### Your Architecture

- **Model (`UserData`)** ‚Äî the data,
- **DAO (`UserDao`)** ‚Äî your contact with the database, handles SQL, returns models.
- **Database Connection (`DbConnection` & `MySqlConnection`)** ‚Äî the infrastructure, manages connections.
- **View (`LoginView`, `AdminDashboardView`, etc.)** ‚Äî the face, what user sees and interacts with.
- **Controller (`LoginController`, `AdminDashboardController`, etc.)** ‚Äî the mind, directs traffic and logic.

---

### üöÄ 1. **Application Start: `main.main` Class**

- **Class Used**: `main`
- **Method**: `public static void main(String[] args)`

```java
javax.swing.SwingUtilities.invokeLater(() -> {
    RegisterView registerView = new RegisterView();
    RegisterController registerController = new RegisterController(registerView);
    registerController.open();
});

```

**What happens:**

- Java schedules this code on the Event Dispatch Thread (EDT) using `SwingUtilities.invokeLater()`, which is standard for safe GUI operations.
- `RegisterView` object is created. This class extends `JFrame` and is your **Signup GUI** (View).
- A `RegisterController` object is then created with `RegisterView` passed into its constructor. It:
    - Connects the GUI with logic
    - Adds button listeners
    - Talks to DAO to process registration
- `registerController.open()` sets the view (`RegisterView`) visible.

üß† **Objects Created**:

- `registerView`: GUI window
- `registerController`: Logic layer controlling what happens when user interacts with signup

---

### üßë‚Äçüíª 2. **User Enters Signup Info and Clicks 'Register'**

- **GUI Class**: `RegisterView`
- When the user fills in the fields and clicks **Register**:
    - `registerButton.addActionListener(...)` triggers the **listener added by the controller**

### üë®‚Äç‚úàÔ∏è 3. **Controller Handles the Event**

- **Class**: `RegisterController`
- **Method**: The anonymous ActionListener inside `addRegisterListener()` is triggered

```java
String username = view.getUsername();
String email = view.getEmail();
String password = view.getPassword();
String role = view.getRole();

```

These methods extract the text inputs from the GUI fields.

- **A `UserData` object is created**:

```java
UserData user = new UserData(username, email, password, role);

```

This is a data carrier. It holds user details and passes it to the database layer.

---

### üíΩ 4. **Saving to Database via DAO**

- **Class**: `UserDao`
- **Method**: `public boolean registerUser(UserData user)`

Here‚Äôs the flow inside:

### 4.1. **Database Connection**

- **Interface Used**: `DbConnection`
- **Implementation**: `MySqlConnection`
- `openConnection()` is called:

```java
String url = "jdbc:mysql://localhost:3306/hostel";
String username = "root";
String password = "admin123";
Class.forName("com.mysql.cj.jdbc.Driver");
Connection conn = DriverManager.getConnection(url, username, password);

```

- The JDBC driver is loaded
- Connection is established and returned to DAO

### 4.2. **SQL Insertion**

```java
String query = "INSERT INTO users (username, email, password, role) VALUES (?, ?, ?, ?)";
PreparedStatement stmt = conn.prepareStatement(query);

```

- Values from the `UserData` object are inserted into the query safely using `PreparedStatement`.

### 4.3. **Execution**

```java
int rowsInserted = stmt.executeUpdate();

```

- Executes the query and stores how many rows were inserted
- If 1, success is returned. Else, false is returned

### 4.4. **Connection Close**

- The DAO calls `closeConnection(conn)` using the `DbConnection` interface.

‚úÖ **Outcome**: User registered in the database, success message shown in GUI.

---

### ‚ùå 5. **User Closes App**

- This simply closes the JFrame. No memory is retained.

---

### üîÅ 6. **User Opens App Again and Clicks ‚ÄúAlready have an account‚Äù**

- This calls `RegisterView` method which opens `LoginView`
- A new `LoginController` is created:

```java
new LoginController(new LoginView()).open();

```

---

### üîë 7. **User Logs In**

- **Class**: `LoginController`
- Button click listener is triggered.

### 7.1. **Input Extraction**

```java
String email = view.getEmail();
String password = view.getPassword();
String role = view.getRole();

```

### 7.2. **Database Authentication**

```java
UserDao dao = new UserDao();
boolean isAuthenticated = dao.authenticateUser(email, password, role);

```

### 7.3. **Inside `authenticateUser` Method**

- Same connection process occurs
- Query:

```sql
SELECT * FROM users WHERE email = ? AND password = ? AND role = ?

```

- If found, returns true.

---

### üß≠ 8. **Controller Navigates to Dashboard**

If user is authenticated and role is "admin":

```java
new AdminDashboardController().open();

```

### Inside `AdminDashboardController`:

```java
this.view = new AdminDashboardView();
this.view.addLogoutListener(e -> close());
view.setVisible(true);

```

- AdminDashboardView is displayed
- Logout button is wired to close current view and open login again

---

### üö™ 9. **User Clicks Logout**

- Button listener (added via `addLogoutListener`) calls:

```java
private void close() {
    view.dispose(); // close current window
    new LoginController(new LoginView()).open(); // re-open login
}

```

And you're back to the login screen.

---

## ‚úÖ Summary of Component Responsibilities

| Class Name | Responsibility |
| --- | --- |
| `main` | Launches GUI on EDT and starts with RegisterView from registercontroller |
| `RegisterView` | GUI for signup |
| `RegisterController` | Handles button click, validates input, and calls DAO |
| `UserData` | Data carrier between GUI, controller, and DAO |
| `DbConnection` (interface) | Abstracts connection logic |
| `MySqlConnection` | Implements connection logic (connects, closes MySQL) |
| `UserDao` | Handles DB operations (register, login/authenticate) |
| `LoginView` | GUI for login |
| `LoginController` | Handles login logic |
| `AdminDashboardView` | GUI shown after admin logs in |
| `AdminDashboardController` | Manages dashboard visibility and logout process |

---

## üß† Final Flow Recap

```
main()
  ‚Üí RegisterView
    ‚Üí RegisterController
      ‚Üí UserData
        ‚Üí UserDao
          ‚Üí MySqlConnection (openConnection)
            ‚Üí INSERT INTO users
              ‚Üí closeConnection
-- close app --
main()
  ‚Üí RegisterView
    ‚Üí LoginController
      ‚Üí UserDao
        ‚Üí SELECT * FROM users returns userdata as exsisting User to the login
          ‚Üí redirect to AdminDashboardController
            ‚Üí show AdminDashboardView
              ‚Üí on Logout ‚Üí close ‚Üí return to Login

```

## ‚úÖ SEQUENCE TO BUILD THIS SYSTEM (THE EASY, LOGICAL ORDER)

Here is the **ideal development sequence** to avoid confusion and minimize bugs:

---

### 1Ô∏è‚É£ **Database First**

- Design and test your `users` table in MySQL Workbench:

### 2Ô∏è‚É£ **MySqlConnection.java**

- Create a reusable method `openConnection()`, `closeConnection()` for all DB operations.

---

### 3Ô∏è‚É£ **UserData.java**

- Create the  class for storing user info:

### 4Ô∏è‚É£ **UserDao.java**

- Implement:
    - `registerUser(UserData user)`
    - `UserData loginUser(String email, String password)`

Test these with `main()` or temporary controller methods.

### 5Ô∏è‚É£ **RegisterView + RegisterController**

- Create the form UI first (`RegisterView`)
- Then handle logic in `RegisterController`
- Connect button ‚Üí collect inputs ‚Üí send to `UserDao.registerUser()`

### 6Ô∏è‚É£ **LoginView + LoginController**

- Create a clean login form UI
- On login button click, call `UserDao.loginUser()`
- Based on returned user role:
    - Redirect to Admin or Warden dashboards

### 7Ô∏è‚É£ **AdminDashboardView + Controller**

- Only add the logout button at first
- Make sure Logout returns to LoginController

---

### 8Ô∏è‚É£ Main

- Add main file entry point of program and show the registerview their.
